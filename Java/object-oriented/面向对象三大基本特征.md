  1. [封装（Encapsulation）](#封装encapsulation)
  2. [继承（Inheritance）](#继承inheritance)
        * [super 关键字](#super-关键字)
  3. [多态（Polymorphism）](#多态polymorphism)
        * [多态的好处：](#多态的好处)
        * [多态中的两种类型转换：](#多态中的两种类型转换)
        * [重写（override）](#重写override)
  4. [重写和重载区别](#重写和重载区别)

## 封装（Encapsulation）

封装是将代码及其处理的数据绑定在一起的一种编程机制，该机制保证了程序和数据都不受外部干扰且不被误用。封装的目的在于保护信息，Java 的基本封装单位是**类**。

Java 提供了私有和公有的访问模式，类的公有接口代表外部的用户应该知道或可以知道的每件东西，私有的方法数据只能通过该类的成员代码来访问，这就可以确保不会发生不希望的事情。

**封装的优点**：

1. 良好的封装能够减少耦合，提高系统的独立性。
2. 类内部的结构可以自由修改
3. 隐藏类的实现细节，保护类中的信息。
4. 提高代码的复用性。

----

## 继承（Inheritance）

利用继承，人们可以基于已存在的类构造一个新类。继承已存在的类就是复用（继承）这些类的方法和域（属性），而且在此基础上，还可以添加一些新的方法和域，以满足新的需求。**所以继承需要符合的关系是 `is-a`，父类更加通用，子类更加具体。**

<img src="https://tva1.sinaimg.cn/large/00831rSTly1gd0dsqk29aj31580jaacs.jpg" style="zoom:33%;" />

使用 `extends` 关键字来表示继承。已存在的类被称为超类（superclass）、基类（base class）或者父类（father class）；新类称为子类（subclass）、派生类（derived class）或者孩子类（child class）。<font color=orange>Object 是所有类的超类。</font>

继承概念的实现方式有二类：实现继承与接口继承。实现继承是指直接使用基类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；

**继承的好处**：

1. 减少代码的冗余性（重复性），代码更加简洁；
2. 可维护性高；
3. 提高代码的复用性。

----

#### super 关键字

1、可以通过 super 来实现对父类成员的访问，用来引用当前对象的父类。

<img src="https://tva1.sinaimg.cn/large/006tNbRwly1gb6rcn1u95j318s0qan4o.jpg" alt="newname2020-01-2320.15.43" style="zoom:50%;" />

2、调用父类构造方法。子类不会获得父类的构造器，但子类可以调用父类构造器的初始化代码。在子类中调用父类的构造方法只能用 super 来完成，**且 super 调用只能位于子类构造方法的第一行**。

```java
class A{
  int a;
  public A(){}
  public A(int a){
    this.a = a;
  }
}

class AA extends A{
  int a;
  public AA(){}
  public AA(int a,int a1){
    super(a);
    this.a = a1;
  }
}
```

----

## 多态（Polymorphism）

子类对象可以直接赋给父类变量，但运行时依然表现出子类的行为特征，这意味着一个类实例的相同方法在不同情形有不同表现形式。<font color=red>多态三要素：继承、重写、父类引用指向子类对象。</font>

在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。

#### 多态的好处：

- **可替换性（substitutability）：**多态对已存在代码具有可替换性。例如，多态对圆 Circle 类工作，对其他任何圆形几何体，如圆环，也同样工作。
- **可扩充性（extensibility）：**多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。
- **接口性（interface-ability）：**多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。
- **灵活性（flexibility）：**它在应用中体现了灵活多样的操作，提高了使用效率。
- **简化性（simplicity）：**多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。

#### 多态中的两种类型转换：

**（1）向上转型，其实也就是构成多态，也叫做自动类型转换**

```java
Pet p = new Dog(); //构成多态，也就是向上转型；子---->父
```

注意：当构成多态或向上转型时，对象名只能访问父类中的实例变量和父类中的实例方法，但是优先访问子类重写以后的方法

**（2）向下转型，也叫做强制类型转换：父---- >子**

当构成多态时，并且要访问子类独有的实例变量或实例方法，则必须进行向下转型也叫做强制类型转换。

当进行向下转型时可能出现类型转换异常 `java.lang.ClassCastException`，属于运行错误。需要利用 if 语句和 instanceof 运算符来判断两个对象的类型是否一致。

```java
//建议向下转型/强制类型转换时，先进行判断，如果满足则再进行向下转型。
Pet p = new Cat(); //构成多态
if(p instanceof Dog){
  Dog dog = (Dog)p;
  dog.play();
}else if(p instanceof Cat){
  Cat cat = (Cat)p;
  cat.catching();
}
```

#### 重写（override）

> 多态、继承和重写是相辅相成的，继承是多态的基础，多态是有了继承后功能的延伸，而重写则是具体实现的工具。
>
> 当父类的中的方法不能满足子类的需求时，则在子类中重写（也叫覆盖）父类的方法，定义属于自己的行为，也就是说子类可以根据自己的需求实现父类的方法。

**注意事项：**

1. 参数列表必须完全与被重写方法的相同。
2. 返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（Java5 及更早版本返回类型要一样，Java7 及更高版本可以不同）。
3. 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。
4. 父类的成员方法只能被它的子类重写。
5. 声明为 final 的方法不能被重写。
6. 声明为 static 的方法不能被重写，但是能够被再次声明。
7. 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。
8. 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。
9. 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。
11. <font color=orange>只有继承的方法才能重写，但是构造方法不能重写。</font>

----

## 重写和重载区别

> 1. 重载是一个编译期概念、重写是一个运行期间概念。
> 2. 重载遵循所谓「编译期绑定」，即在编译时根据参数变量的类型判断应该调用哪个方法。
> 3. 重写遵循所谓「运行期绑定」，即在运行的时候，根据引用变量所指向的实际对象的类型来调用方法
> 4. 因为在编译期已经确定调用哪个方法，所以重载并不是多态。而重写是多态。重载只是一种语言特性，是一种语法规则，与多态无关，与面向对象也无关。（注：严格来说，重载是编译时多态，即静态多态。但是，Java中提到的多态，在不特别说明的情况下都指动态多态）
>
> > **方法签名**
> >
> > 方法签名由`方法名称`和`方法的参数列表`（形参类型和形参顺序）共同组成。
> >
> > 需要注意的是：方法签名不包括方法的返回值类型和访问修饰符。

**重写**：是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。**即外壳不变，核心重写！**

**重载**：多个方法，方法名相同，参数列表不同（参数个数、参数位置、参数类型 ），这就构成了方法的重载。与返回值和访问权限无关。

> **重载规则:**
>
> 1. 被重载的方法必须改变参数列表（参数个数或类型不一样）；
> 2. 被重载的方法可以改变返回类型；
> 3. 被重载的方法可以改变访问修饰符；
> 4. 被重载的方法可以声明新的或更广的检查异常；
> 5. 方法能够在同一个类中或者在一个子类中被重载。
> 6. 无法以返回值类型作为重载函数的区分标准。

**总结**

方法的重写（Overriding）和重载（Overloading）是 Java 多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。

- 方法重载是一个类中定义了多个方法名相同，而他们的参数的数量不同或数量相同而类型和次序不同，则称为方法的重载（Overloading）。
- 方法重写是在子类存在方法与父类的方法的名字相同，而且参数的个数与类型一样，返回值也一样的方法，就称为重写（Overriding）。
- 方法重载是一个类的多态性表现，而方法重写是子类与父类的一种多态性表现。