## 五大原则

> 摘自 Github 之 toBeTopJavaer 项目：[五大基本原则](https://github.com/hollischuang/toBeTopJavaer/blob/master/basics/java-basic/principle.md)

![newname2020-03-1823.18.53](https://tva1.sinaimg.cn/large/00831rSTly1gczgucqoiij30z605c74v.jpg)



**（1）单一职责原则 SRP（Single Responsibility Principle）： 应该有且只有一个原因引起类的变更。**

> 通俗的来说，一个类，一个方法只应该做一件事情。
>
> 职责过多，可能引起它变化的原因就越多，这将导致职责依赖，相互之间就产生影响，从而大大损伤其内聚性和耦合度。

**（2）开闭原则 OCP（Open Close Principle）：一个软件实体（如类、模块和函数）应该对扩展开放，对修改关闭。**

> 1. 对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。
> 2. 对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对其进行任何尝试的修改。
>
> 编写的代码应该面向扩展开放，而尽量不要通过修改现有代码来完成需求变更。尽量面向接口编程。

**（3）里氏替换原则 LSP（Liskov Substitution Principle）：子类对象能够替换父类对象，而程序逻辑不变。**

> 其核心思想是：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。在父类和子类的具体行为中，必须严格把握继承层次中的关系和特征，将基类替换为子类，程序的行为不会发生任何变化。同时，这一约束反过来则是不成立的。
>
> 里氏替换原则，主要着眼于对抽象和多态建立在继承的基础上，因此只有遵循了里氏替换原则，才能保证继承复用是可靠地。实现的方法是面向接口编程：将公共部分抽象为基类接口或抽象类，在子类中通过覆写父类的方法实现新的方式支持同样的职责。里氏替换原则是关于继承机制的设计原则，违反了里氏替换原则就必然导致违反开放封闭原则。里氏替换原则能够保证系统具有良好的拓展性，同时实现基于多态的抽象机制，能够减少代码冗余，避免运行期的类型判别。
>
> > **多态是不是违反了 LSP ？**
> >
> > 1、里氏替换原则是针对继承而言的，子类不重写父类的方法且子类可以通过新增方法来扩展功能，此时就是符合 LSP 的。
> >
> > 2、如果继承的目的是多态，那么就不能从可实例化的父类中继承，而是要使用基于**抽象类**和**接口**的继承，但是此时子类必然要重写父类方法。因此里氏转换原则和多态是相辅相成的！

**（4）依赖倒置原则 DIP（Dependence Inversion Principle）：高层模块不要依赖低层模块，所以依赖都应该是抽象的，抽象不应该依赖于具体细节，而具体细节应该依赖于抽象。其核心思想是：要面向接口编程，不要面向实现编程。**

> **低层模块：**不可分割的原子逻辑就是低层模块
>
> **高层模块：**低层模块的组装合成后就是高层模块
>
> **抽象：**Java 中体现为基类，抽象类，接口，而不单指抽象类
>
> **细节：**体现为子类，实现类
>
> 通俗点讲，该原则包含以下几点要素：
>
> - 模块间的依赖应该通过抽象发生，具体实现类之间不应该建立依赖关系。
> - 接口或者抽象类不依赖于实现类，否则就失去了抽象的意义。
> - 实现类依赖于接口或者抽象类
>
> 总结起来，一句话：**「面向接口编程」**。

**（5）接口分离原则 ISP（Interface-Segregation Principle）：客户端不应该依赖它不需要的接口；类间的依赖应该建立在最小的接口上。**

> 使用接口时应该建立单一接口，不要建立臃肿庞大的接口，尽量给调用者提供专门的接口，而非多功能接口。

----



扩展阅读：[写了这么多年代码，你真的了解SOLID吗？](https://insights.thoughtworks.cn/do-you-really-know-solid/)